// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"net/http"
	"time"
)

// FetchSubscriptionUsageGranularity - This determines the windowing of usage reporting.
type FetchSubscriptionUsageGranularity string

const (
	FetchSubscriptionUsageGranularityDay FetchSubscriptionUsageGranularity = "day"
)

func (e FetchSubscriptionUsageGranularity) ToPointer() *FetchSubscriptionUsageGranularity {
	return &e
}

func (e *FetchSubscriptionUsageGranularity) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "day":
		*e = FetchSubscriptionUsageGranularity(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FetchSubscriptionUsageGranularity: %v", v)
	}
}

// FetchSubscriptionUsageViewMode - `periodic` returns usage for each window (configured by `granularity`) and `cumulative` returns the usage since the beginning of the billing period. The default is `periodic`.
type FetchSubscriptionUsageViewMode string

const (
	FetchSubscriptionUsageViewModePeriodic   FetchSubscriptionUsageViewMode = "periodic"
	FetchSubscriptionUsageViewModeCumulative FetchSubscriptionUsageViewMode = "cumulative"
)

func (e FetchSubscriptionUsageViewMode) ToPointer() *FetchSubscriptionUsageViewMode {
	return &e
}

func (e *FetchSubscriptionUsageViewMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "periodic":
		fallthrough
	case "cumulative":
		*e = FetchSubscriptionUsageViewMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FetchSubscriptionUsageViewMode: %v", v)
	}
}

type FetchSubscriptionUsageRequest struct {
	// When specified in conjunction with `group_by`, this parameter filters usage to a single billable metric. Note that both `group_by` and `billable_metric_id` must be specific together.
	BillableMetricID *string `queryParam:"style=form,explode=true,name=billable_metric_id"`
	// This determines the windowing of usage reporting.
	Granularity *FetchSubscriptionUsageGranularity `queryParam:"style=form,explode=true,name=granularity"`
	// When specified in conjunction with `billable_metric_id`, this parameter groups by the key provided. Note that both `group_by` and `billable_metric_id` must be specific together.
	GroupBy        *string `queryParam:"style=form,explode=true,name=group_by"`
	SubscriptionID string  `pathParam:"style=simple,explode=false,name=subscription_id"`
	// Usage returned is _exclusive_ of `timeframe_end`
	TimeframeEnd *time.Time `queryParam:"style=form,explode=true,name=timeframe_end"`
	// Usage returned is _inclusive_ of `timeframe_start`
	TimeframeStart *time.Time `queryParam:"style=form,explode=true,name=timeframe_start"`
	// `periodic` returns usage for each window (configured by `granularity`) and `cumulative` returns the usage since the beginning of the billing period. The default is `periodic`.
	ViewMode *FetchSubscriptionUsageViewMode `queryParam:"style=form,explode=true,name=view_mode"`
}

type FetchSubscriptionUsage200ApplicationJSONDataModelType string

const (
	FetchSubscriptionUsage200ApplicationJSONDataModelTypeUsage FetchSubscriptionUsage200ApplicationJSONDataModelType = "usage"
)

func (e FetchSubscriptionUsage200ApplicationJSONDataModelType) ToPointer() *FetchSubscriptionUsage200ApplicationJSONDataModelType {
	return &e
}

func (e *FetchSubscriptionUsage200ApplicationJSONDataModelType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "usage":
		*e = FetchSubscriptionUsage200ApplicationJSONDataModelType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FetchSubscriptionUsage200ApplicationJSONDataModelType: %v", v)
	}
}

type FetchSubscriptionUsage200ApplicationJSONDataUsage struct {
	Quantity       string    `json:"quantity"`
	TimeframeEnd   time.Time `json:"timeframe_end"`
	TimeframeStart time.Time `json:"timeframe_start"`
}

type FetchSubscriptionUsage200ApplicationJSONData struct {
	ID        string                                                `json:"id"`
	ModelType FetchSubscriptionUsage200ApplicationJSONDataModelType `json:"model_type"`
	Usage     []FetchSubscriptionUsage200ApplicationJSONDataUsage   `json:"usage"`
}

// FetchSubscriptionUsage200ApplicationJSON - OK
type FetchSubscriptionUsage200ApplicationJSON struct {
	Data []FetchSubscriptionUsage200ApplicationJSONData `json:"data,omitempty"`
}

type FetchSubscriptionUsageResponse struct {
	ContentType string
	StatusCode  int
	RawResponse *http.Response
	// OK
	FetchSubscriptionUsage200ApplicationJSONObject *FetchSubscriptionUsage200ApplicationJSON
}
