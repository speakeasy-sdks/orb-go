// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package operations

import (
	"Orb/pkg/models/shared"
	"Orb/pkg/types"
	"encoding/json"
	"fmt"
	"net/http"
)

type AddLedgerEntryExternalIDRequestBodyEntryType string

const (
	AddLedgerEntryExternalIDRequestBodyEntryTypeIncrement        AddLedgerEntryExternalIDRequestBodyEntryType = "increment"
	AddLedgerEntryExternalIDRequestBodyEntryTypeDecrement        AddLedgerEntryExternalIDRequestBodyEntryType = "decrement"
	AddLedgerEntryExternalIDRequestBodyEntryTypeExpirationChange AddLedgerEntryExternalIDRequestBodyEntryType = "expiration_change"
)

func (e AddLedgerEntryExternalIDRequestBodyEntryType) ToPointer() *AddLedgerEntryExternalIDRequestBodyEntryType {
	return &e
}

func (e *AddLedgerEntryExternalIDRequestBodyEntryType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "increment":
		fallthrough
	case "decrement":
		fallthrough
	case "expiration_change":
		*e = AddLedgerEntryExternalIDRequestBodyEntryType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AddLedgerEntryExternalIDRequestBodyEntryType: %v", v)
	}
}

// AddLedgerEntryExternalIDRequestBodyInvoiceSettings - Passing `invoice_settings` automatically generates an invoice for the newly added credits. If `invoice_settings` is passed, you must specify `per_unit_cost_basis`, as the calculation of the invoice total is done on that basis.
type AddLedgerEntryExternalIDRequestBodyInvoiceSettings struct {
	// Whether the credits purchase invoice should auto collect with the customer's saved payment method.
	AutoCollection bool `json:"auto_collection"`
	// An optional memo to display on the invoice.
	Memo *string `json:"memo,omitempty"`
	// The net terms determines the difference between the invoice date and the issue date for the invoice. If you intend the invoice to be due on issue, set this to 0.
	NetTerms float64 `json:"net_terms"`
}

type AddLedgerEntryExternalIDRequestBody struct {
	// The number of credits to effect. Note that this is required for increment or decrement operations.
	Amount *float64 `json:"amount,omitempty"`
	// The ID of the block affected by an `expiration_change`
	BlockID *string `json:"block_id,omitempty"`
	// Optional metadata that can be specified when adding ledger results via the API. For example, this can be used to note an increment refers to trial credits, or for noting corrections as a result of an incident, etc.
	Description *string                                      `json:"description,omitempty"`
	EntryType   AddLedgerEntryExternalIDRequestBodyEntryType `json:"entry_type"`
	// A future date (specified in YYYY-MM-DD format) that denotes when this credit balance should expire.
	//
	//
	ExpiryDate *types.Date `json:"expiry_date,omitempty"`
	// Passing `invoice_settings` automatically generates an invoice for the newly added credits. If `invoice_settings` is passed, you must specify `per_unit_cost_basis`, as the calculation of the invoice total is done on that basis.
	InvoiceSettings *AddLedgerEntryExternalIDRequestBodyInvoiceSettings `json:"invoice_settings,omitempty"`
	// User-specified key/value pairs for the ledger entry resource.
	Metadata map[string]interface{} `json:"metadata,omitempty"`
	// Can only be specified when `entry_type=increment`. How much, in USD, a customer paid for a single credit in this block
	PerUnitCostBasis *string `json:"per_unit_cost_basis,omitempty"`
	// A future date (specified in YYYY-MM-DD) used for `expiration_change`
	TargetExpiryDate *types.Date `json:"target_expiry_date,omitempty"`
}

type AddLedgerEntryExternalIDRequest struct {
	RequestBody        *AddLedgerEntryExternalIDRequestBody `request:"mediaType=application/json"`
	ExternalCustomerID string                               `pathParam:"style=simple,explode=false,name=external_customer_id"`
}

type AddLedgerEntryExternalIDResponse struct {
	ContentType string
	// OK
	CreditLedgerEntry *shared.CreditLedgerEntry
	StatusCode        int
	RawResponse       *http.Response
}
